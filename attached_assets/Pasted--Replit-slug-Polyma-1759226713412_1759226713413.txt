# Цель

Сделать на Replit одностраничное веб‑приложение, которое по ссылке или slug события Polymarket строит «зеркало» страницы почти 1:1 (титул, дедлайн, исходы/страйки, котировки YES/NO), **парсит цены по каждому страйку** и в правой колонке добавляет **автоматические расчёты** для дельта‑нейтральных лестниц (YES/NO), рекомендации по объёму юнитов и лимитам, суммарные риски/профит и быстрые ссылки на размещение ордеров.

---

## Ключевые сценарии

1. Пользователь вставляет **URL или slug** Polymarket → видит слева «зеркало» события, справа — расчёты по всем страйкам и блок «Рекомендованные ордера».
2. Задаёт **Budget ($)**, **Fee (%)**, **Bias** (направление), **Risk Cap ($)**, режим распределения (симметрия/ядро‑NO/ядро‑YES) → получает юниты/лимиты для каждой ступени.
3. Нажимает **Refresh** или включает **Auto‑refresh** → котировки и расчёты обновляются.
4. Копирует **JSON ордеров** или кликает в «Открыть маркет» для выбранного страйка.

---

## Источники данных

* **Полимаркет (публично):**

  * Gamma REST: события/рынки/метаданные (например, `/events`, `/markets`).
  * CLOB REST: книги заявок и котировки (mid/top‑of‑book), плюс WSS‑каналы для лайв‑обновлений.
  * Data‑API (торги/позиции) — опционально для истории.
* **Спотовая цена базового актива (BTC/ETH/SOL и т.п.):** провайдер по умолчанию (например, Coinbase/CoinGecko) с переключаемым источником.
* **Фолбэк:** если API временно недоступны, парсинг HTML (ограниченный режим, без лайва).

> Параметры источников оформляем в `.env` (ключи, базовые URL, таймауты, лимиты).

---

## Архитектура (Replit)

**Стек (минимализм, скорость разработки):**

* Backend: **Python + FastAPI** (эндпоинты данных и SSR‑шаблоны на Jinja2).
* Frontend: легковесный **HTMX + Tailwind** (без сборки), один layout.
* Live‑обновления: **WSS** (через бэкенд‑прокси) или периодический **polling**.
* Формулы: чистый Python, один модуль `strategy_engine.py`.
* Хранение: in‑memory кэш (TTL) для markets/books; опционально redis (ключи `pm:*`).

**Структура проекта**

```
replit-pm-mirror/
  app.py                 # FastAPI маршруты (UI + API)
  strategy_engine.py     # расчёты, юнит‑распределение, EV/PL
  polymarket_client.py   # обёртка над Gamma/CLOB/Data-API + фолбэк HTML
  price_client.py        # источники цены базового актива
  templates/
    base.html            # Tailwind layout (две колонки)
    mirror.html          # страница зеркала + панель решений
  static/
    mirror.css           # мелочи по стилю
  .env.example
  README.md
```

---

## Модель данных (внутренняя)

```ts
Event {
  id: string
  title: string
  description?: string
  resolveTime?: datetime
  slug: string
  markets: Market[]
}

Market {
  id: string
  question: string         // «Will BTC ≥ 120k by 2025‑12‑31?»
  outcomeType: 'binary' | 'multi'
  strike?: StrikeMeta      // распознанная числовая «ступень»
  yesPrice: number         // best bid/ask mid или top‑of‑book
  noPrice: number
  spread: number
  liquidity?: number
}

StrikeMeta {
  raw: string              // исходная строка
  K: number                // числовой страйк (в USD)
  unit: 'USD' | 'KUSD' | 'OTHER'
}

Quote {
  yesBid: number; yesAsk: number; noBid: number; noAsk: number; midYes: number; midNo: number;
}
```

---

## Распознавание «страйков»

1. Парсим `market.question` и/или `event.title` регулярками:

   * Ищем числовые пороги: `$?\s?(\d+[\d,.]*)(k|K|M)?`.
   * Нормализуем `K` → `*1000`, `M` → `*1e6`.
   * Учитываем сравнения: `≥`, `<=`, `over`, `under`, `hit`, `first to`, `before`, `by [date]`.
2. Если удалось выделить массив порогов `K_i`, считаем это **лестницей**; иначе показываем «обычный» бинарник без лестницы (но всё равно считаем пары по доступным рынкам).

---

## Цены YES/NO

* По умолчанию берём **mid**: `(bestAsk + bestBid)/2` для каждой стороны; если нет книги — берём последнюю цену сделки.
* Параметр в UI: `Quote Source = mid | bestAsk/bestBid | lastTrade`.

---

## Базовая цена (Anchor)

* `Anchor = spot(base_asset)` (например, BTC/USD), источник — выпадающий список.
* Если событие без явного базового актива, Anchor можно задать вручную.

---

## Фи/параметры

* `fee_settlement` (по умолчанию 2.0%) — комиссии на выигрыше.
* `slippage_limit` (по умолчанию 0.5–1.0¢) — при генерации лимитов.
* `budget_total` — общий бюджет в $.
* `risk_cap` — макс. допустимый совокупный риск.
* `bias` (‑1..+1) — сдвиг долей вверх/вниз.

---

## Расчёты на страйк

Обозначения для страйка *i*:

* `pY_i` — выбранная котировка YES; `pN_i` — котировка NO (в $ за share, 0..1).
* Выигрышная выплата = $1; проигрышная = $0.
* `f` — `fee_settlement` (доля с **прибыли** выигрыша).

**Максимальный P&L на 1 юнит:**

* YES: `maxProfitY_i = (1 - pY_i) * (1 - f)`, `maxLossY_i = pY_i`.
* NO:  `maxProfitN_i = (1 - pN_i) * (1 - f)`, `maxLossN_i = pN_i`.

**EV с субъективной вероятностью** `q_i` (опционально, если пользователь вводит взгляд):

* YES: `EVY_i = q_i * (1 - pY_i) * (1 - f) - (1 - q_i) * pY_i`.
* NO:  `EVN_i = (1 - q_i) * (1 - pN_i) * (1 - f) - q_i * pN_i`.

В таблице справа считаем для каждого страйка обе стороны и помечаем **предпочтительную** (лучшая EV при равной модели/ограничениях) — или сторону по выбранному **режиму стратегии** (см. ниже).

---

## Режимы стратегии и логика распределения

### 1) Symmetric (дельта‑нейтрально вокруг Anchor)

* Для всех `K_i` ниже Anchor используем **YES** (нижний «пол»), для всех `K_i` выше Anchor — **NO** (верхнее «ядро»).
* Вес ступени `w_i = exp(-β * |(K_i - Anchor)/Anchor|)`; `β` настраивается (по умолчанию 7–12 для «острой» лестницы недельных ивентов).
* Доли бюджета: `B_down = (1 - α) * B`, `B_up = α * B`, где `α = (bias + 1)/2` (α=0.5 при нулевом уклоне).

### 2) Core‑NO (медвежий/защита от взлёта повыше Anchor)

* Выше Anchor — **NO** (плотная ступенчатая «крыша»), ниже — разреженные **YES** (тонкая страховка «пол»).
* Параметр `core_density_up` усиливает веса по `K_i > Anchor` (например, дополнительный множитель 1.5–3.0).

### 3) Core‑YES (бычий)

* Зеркально Core‑NO.

### 4) «Направленный старт» (логика «сначала верх/низ»)

* Переключатель **Up‑first / Down‑first**: при появлении новой цены Anchor/спот, первично заполняем соответствующий сегмент (верхний/нижний) и лишь затем вторую сторону — это влияет на округление юнитов и ограничение `risk_cap`.

---

## Сайзинг юнитов (алгоритм)

Дано: бюджет `B`, набор выбранных страйков `S_up` (NO) и `S_dn` (YES), веса `w_i`, цены `c_i` (стоимость 1 юнита выбранной стороны) и ограничения `risk_cap`.

1. Нормируем веса: `W_up = Σ w_i (i∈S_up)`, `W_dn = Σ w_i (i∈S_dn)`.
2. Цели по бюджету: `B_up = α * B`, `B_dn = (1-α) * B` (c учётом `bias`).
3. Непрерывные юниты: `u_i* = (B_side * (w_i / W_side)) / c_i`.
4. Округляем до целых: `u_i = round(u_i*)`; затем **жадно** корректируем, чтобы |Σ cost - B_side| минимизировать и не пробить `risk_cap`.
5. Проверка «плоскости риска»: хотим приблизительно уравнять `Σ maxLoss_up` и `Σ maxLoss_dn` (с допуском). Если дисбаланс > допуск — масштабируем крупную сторону коэффициентом `κ ∈ (0,1]`.
6. Лимит‑цены: для покупки YES — `limit = min(ask, mid + slippage_limit)`; для NO — `limit = min(ask_no, mid_no + slippage_limit)`.

**Итоги по портфелю:** `TotalCost`, `MaxLoss`, `MaxProfit (best‑case)`, «коридор» результатов, доля на сторону.

---

## UI/UX (wire)

Левая колонка (**Зеркало**):

* Header: заголовок события, дедлайн (TTE), таймер.
* Таблица страйков (как на Polymarket): `Strike | YES bid/ask | NO bid/ask | Vol | Liq`.
* Фильтры/поиск по страйкам.

Правая колонка (**Панель решения**):

* **Input** URL/slug, кнопка **Parse**; Select источника спота; Budget/Fees/Bias/RiskCap; режим стратегии; Quote Source; **Refresh** (R) и **Auto‑refresh** toggle (например, 5–15 c).
* **Per‑strike карточки**: выбранная сторона (YES/NO), юниты, лимит, стоимость, max P&L, EV (если задана `q_i`), ссылка «Открыть маркет».
* **Сводка**: общая стоимость, макс. риск, профиль (мини‑гистограмма распределения юнитов вверх/вниз).
* **Кнопки**: «Скопировать JSON ордеров», «Экспорт в CSV/Sheets».

Микро‑UX:

* Цвета: YES — зелёный; NO — фиолетовый; нейтральные — серые.
* Хлебные крошки по навигации; «paste to parse» с авто‑фокусом.

---

## Эндпоинты

* `GET /` — форма ввода + примеры.
* `GET /mirror?slug=...` — SSR страница с зеркалом и правой панелью.
* `GET /api/event?slug=...` — JSON события и рынков.
* `GET /api/quotes?market_id=...` — котировки (mid/top‑of‑book).
* `POST /api/plan` — вход: бюджет/параметры; выход: массив ордеров и агрегаты.
* `GET /api/spot?symbol=BTC` — текущая цена базового актива.

---

## Псевдокод расчётов

```py
# 1) Получаем событие/рынки
E = gamma.get_event_by_slug(slug)
M = gamma.get_markets(E.id)

# 2) Квоты/книги и спот
for m in M:
    q = clob.get_quotes(m.id, source=quote_source)
    m.yes, m.no = q.midYes, q.midNo

spot = spot_client.get(base_asset)
anchor = params.anchor or spot

# 3) Распознаём страйки
ladder = extract_strikes(M)

# 4) Разбиваем на up/down
S_up = [m for m in ladder if m.K > anchor]
S_dn = [m for m in ladder if m.K < anchor]

# 5) Веса
for m in ladder:
    d = abs(m.K - anchor) / anchor
    m.w = math.exp(-beta * d)

# 6) Сайзинг
orders = size_units(S_up, S_dn, params)

# 7) Агрегаты и возврат
return Plan(orders=orders, totals=calc_totals(orders))
```

---

## Ошибки и фолбэки

* `404 Event`: неверный slug — предлагаем поиск по ключевым словам.
* `No Ladder`: рынки не содержат «ступеней» — показываем простой бинарник и рекомендуем парные рынки того же события.
* `API down`: используем кэш или HTML‑парсинг (read‑only, без лайва), помечаем баннером.

---

## Тест‑кейсы (минимум)

1. Событие с большим числом страйков (≥10) — корректный порядок, нормализация `K`, адекватный вес.
2. Узкий спред vs широкий спред — лимиты не пробивают `slippage_limit`.
3. Bias = ‑1/0/+1 — доли `B_up/B_dn` соблюдены, риск не выходит за `risk_cap`.
4. Нет котировок по части страйков — эти ступени исключаются с заметкой.
5. Режим Up‑first/Down‑first — различие в округлении юнитов отражается.

---

## Принятие (Acceptance)

* **Зеркало** визуально совпадает с Polymarket ≥ 90% (текст/порядок/основные метрики).
* Обновление котировок ≤ 2 с (WS) или ≤ 10 с (polling).
* Расчёт плана < 200 мс на 20+ страйков.
* Сводка показывает `TotalCost`, `MaxLoss`, `MaxProfit`, доли вверх/вниз.
* Экспорт JSON/CSV корректен; лимиты внутри заданного `slippage_limit`.

---

## План работ (итерации)

**v0.1 (текущая ТЗ)**

1. Клиенты Gamma/CLOB/Spot + парсер страйков.
2. SSR‑страница «зеркало + панель» с polling (10 с).
3. StrategyEngine: Symmetric + Core‑NO/YES, Bias, RiskCap, сайзинг.
4. Экспорт JSON, CSV.

**v0.2**

* WebSocket лайв‑обновления, графики спота и премий.
* Профили «пресеты» (бычий/нейтральный/медвежий), сохранение в localStorage.

**v0.3**

* Ввод субъективных `q_i` (по страйкам) → EV‑ранжирование.
* One‑click «ребаланс» при смещении Anchor.

---

## Замечания по соответствию Polymarket

* Не торгуем из приложения; только читаем цены/книги и строим расчёты/ссылки.
* Переменные комиссии и логика выплат параметризованы (уточняются по актуальной политике).
* Поддержка временных зон (по умолчанию Asia/Jerusalem) для дедлайнов и таймеров.

---

## Пример JSON ордера (экспорт)

```json
{
  "market_id": "12345",
  "side": "NO",
  "limit_price": 0.17,
  "quantity": 42,
  "note": "Core-NO, K=120000, anchor=112800"
}
```

---

## Что потребуется на старте

* Replit шаблон (Python + FastAPI), переменные окружения для API‑источников.
* Список примеров slug для быстрой проверки.

---

## Расширения (после v0.3)

* Heatmap риска по времени (TTE) и дистанции от Anchor.
* Импорт/экспорт пресетов (URL‑параметры).
* Интеграция с Google Sheets (API) для логирования планов.
* Нотификации (Telegram) при изменении рекомендаций>порога.
